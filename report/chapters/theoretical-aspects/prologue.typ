#import "@preview/lovelace:0.3.0": *
#import "@preview/lemmify:0.1.7": *
#let (
  definition,
  rules: definition-rules,
) = default-theorems("definition", lang: "en")
#let (
  theorem,
  lemma,
  corollary,
  proof,
  rules: theorem-rules,
) = default-theorems("theorem", lang: "en")

#show: theorem-rules
#show: definition-rules

== Terminology

#definition[In an SPSC/MPSC queue, an enqueue operation $e$ is said to *match* a dequeue operation $d$ if $d$ returns the value that $e$ enqueues. Similarly, $d$ is said to *match* $e$. In this case, both $e$ and $d$ are said to be *matched*.]

#definition[In an SPSC/MPSC queue, an enqueue operation $e$ is said to be *unmatched* if no dequeue operation *matches* it.]

#definition[In an SPSC/MPSC queue, a dequeue operation $d$ is said to be *unmatched* if no enqueue operation *matches* it, in other word, $d$ returns `false`.]

== Preliminaries

In this section, we first formalize the system model in @system-model. Based on this, we describe the aspect-oriented linearizability proof technique for queue to demonstrate dLTQueue and Slotqueue's correctness in @aspect-proof. Additionally, we formulate harmless ABA problem in @ABA-safety. We will base our proofs on these formalisms to prove their correctness.

=== System model <system-model>

Here, we introduce the system model used in our correctness proofs that is compatible with the one in @aspect-proof-paper.

A _data structure_ $D$ is a list of methods. An _object_ $o$ is an instance of a data structure $D$. Each _event_ $e$ is a tuple of the form $(o, M, d_i, d_o)$, where $M$ is a method of the object $o$ and $d_i$, $d_o$ are data inputs and outputs, respectively.

An _invocation action_ and a _response action_ are generated by an event. For an event $e$, we denote $e_i(d_i)$ (or $e_i$ in short) as its invocation action along with the data input and $e_r(d_o)$ (or $e_r$ in short) as its response action along with the data output. A _history_ $h$ is a sequence of invocation actions and response actions generated by some data structure. An event $e$ precedes another event $e'$ in $h$, written $e prec_h e'$, if the response of $e$ occurs before the invocation of $e'$ in $h$. A history $h$ is called _complete_ if it does not have any pending events.

Consider a history $h$. Suppose every enqueue event inserts a unique value. Consider an enqueue event $e$ and a dequeue event $d$. $e$ is said to _match_ $d$ at time $t$ if $e_i$ and $d_r$ both happen before $t$ and $e_i$'s input is $d_r$'s output. In this case, $e$ and $d$ are said to be _matched_ at time $t$. $e$ is said to be _unmatched_ at time $t$ if $e_i$ happens after $t$ or no $d$ exists that $d_r$ happens before $t$ and $e_i$'s input is $d_r$'s output.

=== Aspect-oriented linearizability proof <aspect-proof>

Consider a history $h$. Suppose every enqueue event inserts a unique value. Consider an enqueue event $e$ and a dequeue event $d$. $e$ is said to _match_ $d$ at time $t$ if $e_i$ and $d_r$ both happen before $t$ and $e$'s input is $d$'s output. In this case, $e$ and $d$ are said to be _matched_ at time $t$. $e$ is said to be _unmatched_ at time $t$ if $e_i$ happens after $t$ or no $d$ exists that $d_r$ happens before $t$ and $e$'s input is $d$'s output.

We suppose that every enqueue inserts a unique value. In a complete history $h$ of an MPSC queue, there are 4 types of violation, based on @aspect-proof-paper.
- (`VFresh`): A dequeue returns a value not previously inserted by any enqueue. Formally, there exists a dequeue event that returns `true` at time $t$ but no enqueue event matches it at time $t$.
- (`VRepet`): Two dequeues return the value inserted by the same enqueue. Formally, there exists an enqueue event that matches two dequeue events at some time $t$.
(`VOrd`): Two values are enqueued in a certain order, and a dequeue returns the later value before any dequeue of the earlier value starts. Formally, at some time $t$, there exist enqueue events $e_1$, $e_2$ such that $e_1 prec_h e_2$, $e_2$ matches $d_2$ at time $t$ but $e_1$ is unmatched at time $t$.
- (`VWit`): A dequeue returning `false` even though the queue is never empty during the execution of the dequeue. Formally, there exists a dequeue $d$ starting at time $t$ and returning `false` but there is an enqueue $e$ that finishes before $t$ and is still unmatched at $t$. This notion of `VWit` has been simplified for MPSC and SPSC queues. In the original paper, this violation is more complex to formulate.

We can derive the important @theo:mpsc-linearizable from @aspect-proof-paper.

#theorem[
  Every wait-free MPSC queue implementation is linearizable if all its complete
  histories have none of the `VFresh`, `VRepet`, `VOrd` and `VWit` violations.
] <theo:mpsc-linearizable>

=== ABA-safety <ABA-safety>

Not every ABA problem is unsafe. In this section, we formalize which ABA problem is safe and which is not.

#definition[A *modification instruction* on a variable `v` is an atomic instruction that may change the value of `v` e.g. a store or a CAS.]

#definition[A *successful modification instruction* on a variable `v` is an atomic instruction that changes the value of `v` e.g. a store or a successful CAS.]

#definition[A *CAS-sequence* on a variable `v` is a sequence of instructions of a method $m$ such that:
  - The first instruction is a load $v_0 =$ `load(`$v$`)`.
  - The last instruction is a `CAS(&`$v$`,`$v_0$`,`$v_1$`)`.
  - There's no modification instruction on `v` between the first and the last instruction.
]

#definition[A *successful CAS-sequence* on a variable `v` is a *CAS-sequence* on `v` that ends with a successful CAS.]

#definition[Consider a method $m$ on a concurrent object $S$. $m$ is said to be *ABA-safe* if and only if for any history of method calls produced from $S$, we can reorder any successful CAS-sequences inside an invocation of $m$ in the following fashion:
  - If a successful CAS-sequence is part of an invocation of $m$, after reordering, it must still be part of that invocation.
  - If a successful CAS-sequence by an invocation of $m$ precedes another by that invocation, after reordering, this ordering is still respected.
  - Any successful CAS-sequence by an invocation of $m$ after reordering must not overlap with a successful modification instruction on the same variable.
  - After reordering, all method calls' response events on the concurrent object $S$ stay the same.
]
